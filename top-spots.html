<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOP SPOTS - Ï†ÑÏÑ∏Í≥Ñ Ïù∏Í∏∞ Ïû•ÏÜå Ï∞æÍ∏∞</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700;900&family=Outfit:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a24;
            --bg-hover: #22222e;
            --accent: #6366f1;
            --accent-light: #818cf8;
            --accent-glow: rgba(99, 102, 241, 0.3);
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --text-primary: #ffffff;
            --text-secondary: #9ca3af;
            --text-muted: #6b7280;
            --border: #2a2a3a;
            --border-light: #3a3a4a;
        }

        .light-mode {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-card: #ffffff;
            --bg-hover: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border: #e2e8f0;
            --border-light: #cbd5e1;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            transition: background 0.3s ease, color 0.3s ease;
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            position: sticky;
            top: 0;
            z-index: 100;
            transition: background 0.3s ease;
        }

        .header-content {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            flex-wrap: wrap;
        }

        .logo {
            font-family: 'Outfit', sans-serif;
            font-size: 28px;
            font-weight: 900;
            letter-spacing: -1px;
            background: linear-gradient(135deg, var(--accent) 0%, #a855f7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            flex-shrink: 0;
        }

        .search-container {
            display: flex;
            gap: 8px;
            flex: 1;
            max-width: 600px;
        }

        .search-input {
            flex: 1;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 12px 16px;
            font-size: 14px;
            border-radius: 12px;
            outline: none;
            transition: all 0.2s ease;
            font-family: 'Noto Sans KR', sans-serif;
            min-width: 0;
        }

        .search-input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .search-input::placeholder {
            color: var(--text-muted);
        }

        .icon-btn {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            width: 46px;
            height: 46px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .icon-btn:hover:not(:disabled) {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .icon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .icon-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .search-btn {
            background: linear-gradient(135deg, var(--accent) 0%, #8b5cf6 100%);
            border: none;
            color: white;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Noto Sans KR', sans-serif;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .search-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px var(--accent-glow);
        }

        .search-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Controls Bar */
        .controls-bar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 14px 24px;
            transition: background 0.3s ease;
        }

        .controls-content {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-label {
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }

        .radius-buttons {
            display: flex;
            gap: 4px;
        }

        .radius-btn {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px 12px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .radius-btn:hover {
            background: var(--bg-hover);
        }

        .radius-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .select-control {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 28px 8px 12px;
            font-size: 12px;
            border-radius: 8px;
            cursor: pointer;
            outline: none;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%239ca3af' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 6px center;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .price-filters {
            display: flex;
            gap: 4px;
        }

        .price-btn {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px 10px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .price-btn:hover {
            background: var(--bg-hover);
        }

        .price-btn.active {
            background: var(--success);
            border-color: var(--success);
            color: white;
        }

        /* Category Tabs */
        .tabs-bar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            transition: background 0.3s ease;
        }

        .tabs-content {
            max-width: 1800px;
            margin: 0 auto;
            display: flex;
            gap: 4px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }

        .tabs-content::-webkit-scrollbar {
            display: none;
        }

        .tab-btn {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 14px 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            position: relative;
            font-family: 'Noto Sans KR', sans-serif;
        }

        .tab-btn:hover {
            color: var(--text-primary);
        }

        .tab-btn.active {
            color: var(--accent);
        }

        .tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent);
            border-radius: 3px 3px 0 0;
        }

        .tab-count {
            background: var(--bg-card);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 10px;
            margin-left: 4px;
            color: var(--text-muted);
        }

        .tab-btn.active .tab-count {
            background: var(--accent-glow);
            color: var(--accent);
        }

        /* Main Content */
        .main-content {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 450px;
            gap: 20px;
            min-height: calc(100vh - 220px);
        }

        /* Places List */
        .places-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .results-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
            gap: 8px;
        }

        .results-title {
            font-family: 'Outfit', sans-serif;
            font-size: 18px;
            font-weight: 700;
        }

        .results-meta {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .results-count {
            color: var(--text-secondary);
            font-size: 13px;
        }

        .api-limit-note {
            background: var(--warning);
            color: #000;
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: 600;
        }

        .places-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 16px;
        }

        /* Place Card */
        .place-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .place-card:hover {
            transform: translateY(-4px);
            border-color: var(--accent);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }

        .place-card.highlighted {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .place-image-container {
            position: relative;
            height: 150px;
            background: var(--bg-hover);
        }

        .place-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .place-rank {
            position: absolute;
            top: 10px;
            left: 10px;
            background: var(--accent);
            color: white;
            font-family: 'Outfit', sans-serif;
            font-size: 14px;
            font-weight: 800;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
        }

        .place-rank.gold {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        }

        .place-rank.silver {
            background: linear-gradient(135deg, #9ca3af 0%, #6b7280 100%);
        }

        .place-rank.bronze {
            background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
        }

        .favorite-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.6);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .favorite-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        .favorite-btn.active {
            color: #ef4444;
        }

        .place-type-badge {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            color: white;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
        }

        .place-content {
            padding: 14px;
        }

        .place-name {
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 4px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .place-address {
            color: var(--text-secondary);
            font-size: 11px;
            margin-bottom: 10px;
            display: -webkit-box;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .place-stats {
            display: flex;
            gap: 12px;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stat-icon {
            font-size: 12px;
        }

        .stat-value {
            font-weight: 700;
            font-size: 13px;
        }

        .stat-value.reviews {
            color: var(--accent);
        }

        .stat-value.rating {
            color: var(--warning);
        }

        .stat-value.price {
            color: var(--success);
        }

        /* Map Section */
        .map-section {
            position: sticky;
            top: 90px;
            height: calc(100vh - 240px);
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            overflow: hidden;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Skeleton Loading */
        .skeleton-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            overflow: hidden;
        }

        .skeleton-image {
            height: 150px;
            background: linear-gradient(90deg, var(--bg-hover) 25%, var(--bg-card) 50%, var(--bg-hover) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-content {
            padding: 14px;
        }

        .skeleton-line {
            height: 14px;
            background: linear-gradient(90deg, var(--bg-hover) 25%, var(--bg-card) 50%, var(--bg-hover) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .skeleton-line.short {
            width: 60%;
        }

        .skeleton-line.medium {
            width: 80%;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        /* Empty State */
        .empty-state {
            grid-column: 1 / -1;
            text-align: center;
            padding: 60px 20px;
        }

        .empty-icon {
            font-size: 56px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .empty-text {
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Error State */
        .error-banner {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--danger);
            border-radius: 12px;
            padding: 16px 20px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            grid-column: 1 / -1;
        }

        .error-banner-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .error-banner-content {
            flex: 1;
        }

        .error-banner-title {
            color: var(--danger);
            font-weight: 700;
            margin-bottom: 4px;
        }

        .error-banner-text {
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* No Image */
        .no-image {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 36px;
            opacity: 0.3;
            background: var(--bg-hover);
        }

        /* Location Status */
        .location-status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 12px 20px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .location-status.hidden {
            display: none;
        }

        .location-spinner {
            width: 18px;
            height: 18px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .map-section {
                position: relative;
                top: 0;
                height: 350px;
                order: -1;
            }
        }

        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                align-items: stretch;
            }

            .logo {
                text-align: center;
            }

            .search-container {
                max-width: 100%;
                flex-wrap: wrap;
            }

            .search-input {
                flex: 1 1 100%;
            }

            .header-actions {
                justify-content: center;
            }

            .controls-content {
                justify-content: flex-start;
                overflow-x: auto;
                padding-bottom: 8px;
            }

            .control-group {
                flex-shrink: 0;
            }

            .places-grid {
                grid-template-columns: 1fr;
            }

            .main-content {
                padding: 16px;
            }

            .map-section {
                height: 300px;
            }
        }

        /* Animation */
        .fade-in {
            animation: fadeIn 0.4s ease-out forwards;
            opacity: 0;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-light);
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
            <div class="logo">TOP SPOTS</div>
            <div class="search-container">
                <input list="recentCitiesList" type="text" class="search-input" id="searchInput" placeholder="ÎèÑÏãú, Ï£ºÏÜå, Ïû•ÏÜåÎ™Ö Í≤ÄÏÉâ (Ïòà: Í∞ïÎÇ®Ïó≠, Times Square, Paris)">
                <datalist id="recentCitiesList"></datalist>
                <button class="icon-btn" onclick="getCurrentLocation()" id="locationBtn" title="ÎÇ¥ ÌòÑÏû¨ ÏúÑÏπò">
                    üìç
                </button>
                <button class="search-btn" onclick="handleSearch()" id="searchBtn">Í≤ÄÏÉâ</button>
            </div>
            <div class="header-actions">
                <button class="icon-btn" onclick="toggleTheme()" id="themeToggle" title="ÌÖåÎßà Î≥ÄÍ≤Ω">üåô</button>
            </div>
        </div>
    </header>

    <!-- Controls Bar -->
    <div class="controls-bar">
        <div class="controls-content">
            <div class="control-group">
                <span class="control-label">Î∞òÍ≤Ω</span>
                <div class="radius-buttons">
                    <button class="radius-btn" data-radius="5000" onclick="setRadius(5000)">5km</button>
                    <button class="radius-btn active" data-radius="15000" onclick="setRadius(15000)">15km</button>
                    <button class="radius-btn" data-radius="30000" onclick="setRadius(30000)">30km</button>
                    <button class="radius-btn" data-radius="50000" onclick="setRadius(50000)">50km</button>
                </div>
                <div style="display:flex;align-items:center;gap:8px;margin-left:12px;">
                    <button id="radiusPrev" class="radius-btn" title="Î∞òÍ≤Ω Ï§ÑÏù¥Í∏∞" onclick="changeRadiusStep(-1)">‚óÄ</button>
                    <input id="radiusRange" type="range" min="0" max="9" step="1" value="6" style="width:120px">
                    <button id="radiusNext" class="radius-btn" title="Î∞òÍ≤Ω ÎäòÎ¶¨Í∏∞" onclick="changeRadiusStep(1)">‚ñ∂</button>
                    <span id="radiusValue" style="min-width:48px;text-align:right;color:var(--text-secondary);font-size:13px">15km</span>
                </div>
            </div>

            <div class="control-group">
                <span class="control-label">Ï†ïÎ†¨</span>
                <select class="select-control" id="sortSelect" onchange="applySortAndFilter()">
                    <option value="reviews">Î¶¨Î∑∞ ÎßéÏùÄÏàú</option>
                    <option value="rating">ÌèâÏ†ê ÎÜíÏùÄÏàú</option>
                    <option value="price_low">Í∞ÄÍ≤© ÎÇÆÏùÄÏàú</option>
                    <option value="price_high">Í∞ÄÍ≤© ÎÜíÏùÄÏàú</option>
                </select>
            </div>

            <div class="control-group">
                <span class="control-label">Í≤∞Í≥º</span>
                <select class="select-control" id="countSelect" onchange="handleCountChange()">
                    <option value="10">10Í∞ú</option>
                    <option value="20" selected>20Í∞ú</option>
                </select>
            </div>

            <div class="control-group">
                <span class="control-label">ÌÇ§ÏõåÎìú Í≤ÄÏÉâ</span>
                <input id="customQuery" class="search-input" placeholder="Ïòà: Î£®ÌîÑÌÉë Î∞î, Ïò§ÎßàÏπ¥ÏÑ∏" style="width:220px;padding:8px 10px;font-size:12px">
                <button class="radius-btn" onclick="handleCustomSearch()">Í≤ÄÏÉâ</button>
            </div>

            <datalist id="recentQueriesList"></datalist>

            <div class="control-group">
                <button class="radius-btn" onclick="openCompareUI()">ÎèÑÏãú ÎπÑÍµê</button>
                <button class="radius-btn" onclick="openPlanner()">Îç∞Ïù¥ÌîåÎûòÎÑà</button>
            </div>

            <div class="control-group">
                <span class="control-label">Í∞ÄÍ≤©</span>
                <div class="price-filters">
                    <button class="price-btn active" data-price="all" onclick="togglePrice('all')">Ï†ÑÏ≤¥</button>
                    <button class="price-btn" data-price="0" onclick="togglePrice('0')">Î¨¥Î£å</button>
                    <button class="price-btn" data-price="1" onclick="togglePrice('1')">$</button>
                    <button class="price-btn" data-price="2" onclick="togglePrice('2')">$$</button>
                    <button class="price-btn" data-price="3" onclick="togglePrice('3')">$$$</button>
                    <button class="price-btn" data-price="4" onclick="togglePrice('4')">$$$$</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Category Tabs -->
    <div class="tabs-bar">
        <div class="tabs-content">
            <button class="tab-btn active" data-category="all" onclick="setCategory('all')">
                üåç Ï†ÑÏ≤¥ <span class="tab-count" id="count-all">0</span>
            </button>
            <button class="tab-btn" data-category="attraction" onclick="setCategory('attraction')">
                üèõÔ∏è Í¥ÄÍ¥ëÏßÄ¬∑Î™ÖÏÜå <span class="tab-count" id="count-attraction">0</span>
            </button>
            <button class="tab-btn" data-category="restaurant" onclick="setCategory('restaurant')">
                üçΩÔ∏è ÏùåÏãùÏ†ê <span class="tab-count" id="count-restaurant">0</span>
            </button>
            <button class="tab-btn" data-category="cafe" onclick="setCategory('cafe')">
                ‚òï Ïπ¥Ìéò¬∑Î∞î <span class="tab-count" id="count-cafe">0</span>
            </button>
            <button class="tab-btn" data-category="lodging" onclick="setCategory('lodging')">
                üõèÔ∏è ÏàôÎ∞ï¬∑Ìò∏ÌÖî <span class="tab-count" id="count-lodging">0</span>
            </button>
            <button class="tab-btn" data-category="fine_dining" onclick="setCategory('fine_dining')">
                ü•Ç ÌååÏù∏Îã§Ïù¥Îãù <span class="tab-count" id="count-fine-dining">0</span>
            </button>
            <button class="tab-btn" data-category="favorites" onclick="setCategory('favorites')">
                ‚ù§Ô∏è Ï¶êÍ≤®Ï∞æÍ∏∞ <span class="tab-count" id="count-favorites">0</span>
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <section class="places-section">
            <div class="results-info">
                <h2 class="results-title" id="resultsTitle">Ïû•ÏÜåÎ•º Í≤ÄÏÉâÌïòÏÑ∏Ïöî</h2>
                <div class="results-meta">
                    <span class="results-count" id="resultsCount"></span>
                    <span class="api-limit-note" id="apiLimitNote" style="display: none;">API ÏµúÎåÄ 20Í∞ú</span>
                </div>
            </div>
            <div class="places-grid" id="placesGrid">
                <div class="empty-state">
                    <div class="empty-icon">üîç</div>
                    <h3 class="empty-title">Í≤ÄÏÉâÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî</h3>
                    <p class="empty-text">ÎèÑÏãú, Ï£ºÏÜå, ÎòêÎäî Ïû•ÏÜåÎ™ÖÏùÑ ÏûÖÎ†•ÌïòÍ±∞ÎÇò<br>üìç Î≤ÑÌäºÏúºÎ°ú ÌòÑÏû¨ ÏúÑÏπòÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî</p>
                </div>
            </div>
        </section>

        <aside class="map-section">
            <div id="map"></div>
        </aside>
    </main>

    <!-- Location Status -->
    <div class="location-status hidden" id="locationStatus">
        <div class="location-spinner"></div>
        <span id="locationStatusText">ÏúÑÏπòÎ•º Í∞ÄÏ†∏Ïò§Îäî Ï§ë...</span>
    </div>

    <script>
        const API_KEY = 'AIzaSyCqSLJUWJnLLrXpXFzEwQqcTf3-7prKa-4';
        
        // State
        let currentLocation = { name: '', lat: null, lng: null };
        let currentRadius = 15000;
        let currentCategory = 'all';
        let currentPriceFilter = 'all';
        let isLoading = false;
        let searchDebounceTimer = null;

        // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
        let placesData = {
            all: [],
            attraction: [],
            restaurant: [],
            cafe: [],
            lodging: [],
            fine_dining: []
        };

        // Recent searches / archives
        let recentCities = JSON.parse(localStorage.getItem('recentCities_v1') || '[]');
        let recentQueries = JSON.parse(localStorage.getItem('recentQueries_v1') || '[]');

        // Planner state: array of days each with an array of place IDs
        let planner = JSON.parse(localStorage.getItem('itinerary_v1') || JSON.stringify({ days: [ [] ] }));

        // Distance Matrix cache (session) to reduce repeated requests: key = originLat,originLng|destLat,destLng
        const distanceCache = {};
        let filteredPlaces = [];
        
        // Ï¶êÍ≤®Ï∞æÍ∏∞: Ï†ÑÏ≤¥ Ï†ïÎ≥¥ Ï†ÄÏû• (IDÎßå Ï†ÄÏû•ÌïòÎ©¥ Îã§Î•∏ ÎèÑÏãúÏóêÏÑú Î™ª Î∂àÎü¨Ïò¥)
        let favorites = JSON.parse(localStorage.getItem('favorites_v2') || '[]');
        
        let map = null;
        let markers = [];
        let infoWindow = null;
        let currentLocationMarker = null;

        // Category type mapping for API
        const categoryIncludedTypes = {
            all: [], // Ï†ÑÏ≤¥Îäî ÌÉÄÏûÖ ÌïÑÌÑ∞ ÏóÜÏù¥
            attraction: ['tourist_attraction', 'museum', 'park', 'art_gallery', 'church', 'hindu_temple', 'mosque', 'synagogue', 'zoo', 'aquarium', 'amusement_park', 'stadium', 'historical_landmark', 'cultural_landmark', 'national_park', 'monument'],
            restaurant: ['restaurant', 'meal_takeaway', 'meal_delivery', 'korean_restaurant', 'japanese_restaurant', 'chinese_restaurant', 'italian_restaurant', 'mexican_restaurant', 'thai_restaurant', 'indian_restaurant', 'american_restaurant', 'seafood_restaurant', 'steak_house', 'sushi_restaurant', 'pizza_restaurant', 'hamburger_restaurant', 'fast_food_restaurant'],
            cafe: ['cafe', 'coffee_shop', 'bar', 'night_club', 'bakery', 'dessert_shop', 'ice_cream_shop'],
            lodging: ['lodging', 'hotel', 'guest_house', 'motel', 'inn']
        };

        const typeLabels = {
            'restaurant': 'ÏùåÏãùÏ†ê', 'cafe': 'Ïπ¥Ìéò', 'coffee_shop': 'Ïª§ÌîºÏàç', 'bar': 'Î∞î',
            'night_club': 'ÌÅ¥ÎüΩ', 'bakery': 'Î≤†Ïù¥Ïª§Î¶¨', 'tourist_attraction': 'Í¥ÄÍ¥ëÏßÄ',
            'museum': 'Î∞ïÎ¨ºÍ¥Ä', 'park': 'Í≥µÏõê', 'art_gallery': 'Í∞§Îü¨Î¶¨', 'church': 'ÏÑ±Îãπ',
            'zoo': 'ÎèôÎ¨ºÏõê', 'aquarium': 'ÏàòÏ°±Í¥Ä', 'amusement_park': 'ÎÜÄÏù¥Í≥µÏõê',
            'stadium': 'Í≤ΩÍ∏∞Ïû•', 'historical_landmark': 'Ïó≠ÏÇ¨Î™ÖÏÜå', 'cultural_landmark': 'Î¨∏ÌôîÎ™ÖÏÜå',
            'national_park': 'Íµ≠Î¶ΩÍ≥µÏõê', 'monument': 'Í∏∞ÎÖêÎ¨º', 'korean_restaurant': 'ÌïúÏãù',
            'japanese_restaurant': 'ÏùºÏãù', 'chinese_restaurant': 'Ï§ëÏãù', 'italian_restaurant': 'Ïù¥ÌÉàÎ¶¨Ïïà',
            'mexican_restaurant': 'Î©ïÏãúÏπ∏', 'thai_restaurant': 'ÌÉúÍµ≠Ïãù', 'indian_restaurant': 'Ïù∏ÎèÑÏãù',
            'american_restaurant': 'ÎØ∏Íµ≠Ïãù', 'seafood_restaurant': 'Ìï¥ÏÇ∞Î¨º', 'steak_house': 'Ïä§ÌÖåÏù¥ÌÅ¨',
            'sushi_restaurant': 'Ïä§Ïãú', 'pizza_restaurant': 'ÌîºÏûê', 'hamburger_restaurant': 'Î≤ÑÍ±∞',
            'fast_food_restaurant': 'Ìå®Ïä§Ìä∏Ìë∏Îìú', 'dessert_shop': 'ÎîîÏ†ÄÌä∏', 'ice_cream_shop': 'ÏïÑÏù¥Ïä§ÌÅ¨Î¶º',
            'meal_takeaway': 'Ìè¨Ïû•', 'meal_delivery': 'Î∞∞Îã¨', 'point_of_interest': 'Î™ÖÏÜå',
            'establishment': 'ÏãúÏÑ§', 'food': 'ÏùåÏãù', 'lodging': 'ÏàôÎ∞ï', 'store': 'ÏÉÅÏ†ê',
            'shopping_mall': 'ÏáºÌïëÎ™∞'
        };

        // Radius to zoom mapping
        const radiusToZoom = {
            5000: 14,
            15000: 12,
            30000: 11,
            50000: 10
        };

        // Discrete radius steps (meters) from very narrow to very wide
        const radiusSteps = [500, 1000, 2000, 3000, 5000, 10000, 15000, 20000, 30000, 50000];

        // Initialize Map
        function initMap() {
            try {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: 37.5665, lng: 126.9780 },
                    zoom: 12,
                    styles: getMapStyles(),
                    disableDefaultUI: false,
                    zoomControl: true,
                    mapTypeControl: false,
                    streetViewControl: false,
                    fullscreenControl: true
                });
                infoWindow = new google.maps.InfoWindow();
                updateFavoritesCount();
                    // attach wheel listener to map container to adjust search radius by scroll
                const mapEl = document.getElementById('map');
                if (mapEl) {
                    mapEl.addEventListener('wheel', (e) => {
                        // prevent page scroll when over map
                        e.preventDefault();
                        // change radius by one index in radiusSteps
                        const curIndex = radiusSteps.findIndex(r => r === currentRadius);
                        const index = curIndex === -1 ? radiusSteps.findIndex(r => r >= currentRadius) : curIndex;
                        if (e.deltaY < 0) {
                            // scroll up -> wider
                            const nextIndex = Math.min((index === -1 ? 0 : index) + 1, radiusSteps.length - 1);
                            const next = radiusSteps[nextIndex];
                            if (next !== currentRadius) setRadius(next);
                        } else {
                            // scroll down -> narrower
                            const nextIndex = Math.max((index === -1 ? 0 : index) - 1, 0);
                            const next = radiusSteps[nextIndex];
                            if (next !== currentRadius) setRadius(next);
                        }
                    }, { passive: false });
                }
            } catch(e) {
                console.error('Map init error:', e);
                document.getElementById('map').innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ef4444;font-size:13px;padding:20px;text-align:center">‚ö†Ô∏è ÏßÄÎèÑÎ•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.<br>' + e.message + '</div>';
            }
        }
        window.initMap = initMap;

        // API Ïù∏Ï¶ù Ïã§Ìå® Ìï∏Îì§Îü¨
        window.gm_authFailure = function() {
            document.getElementById('map').innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ef4444;font-size:13px;padding:20px;text-align:center">‚ö†Ô∏è Google Maps API ÌÇ§ Ïò§Î•ò<br><small>Cloud ConsoleÏóêÏÑú Maps JavaScript APIÍ∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏ÌïòÏÑ∏Ïöî</small></div>';
            console.error('Google Maps API Ïù∏Ï¶ù Ïã§Ìå® - API ÌÇ§ ÎòêÎäî Maps JavaScript API ÎØ∏ÌôúÏÑ±Ìôî');
        };

        function getMapStyles() {
            const isDark = !document.body.classList.contains('light-mode');
            if (isDark) {
                return [
                    { elementType: 'geometry', stylers: [{ color: '#1a1a24' }] },
                    { elementType: 'labels.text.stroke', stylers: [{ color: '#1a1a24' }] },
                    { elementType: 'labels.text.fill', stylers: [{ color: '#746855' }] },
                    { featureType: 'water', elementType: 'geometry', stylers: [{ color: '#0e0e14' }] },
                    { featureType: 'road', elementType: 'geometry', stylers: [{ color: '#2a2a3a' }] },
                    { featureType: 'poi', elementType: 'geometry', stylers: [{ color: '#22222e' }] }
                ];
            }
            return [];
        }

        // Debounced search
        function handleSearch() {
            if (searchDebounceTimer) clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(() => {
                searchLocation();
            }, 300);
        }

        function handleCountChange() {
            if (currentLocation.lat && currentLocation.lng) {
                searchAllCategories();
            }
        }

        // Search location (city, address, place name)
        async function searchLocation() {
            const query = document.getElementById('searchInput').value.trim();
            if (!query) {
                alert('Í≤ÄÏÉâÏñ¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            setLoading(true);

            try {
                const response = await fetch(
                    `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(query)}&key=${API_KEY}`
                );
                const data = await response.json();

                if (data.status === 'OK' && data.results.length > 0) {
                    const list = data.results.slice(0, 5);
                    if (list.length === 1) {
                        const result = list[0];
                        const location = result.geometry.location;
                        currentLocation = {
                            name: result.formatted_address,
                            lat: location.lat,
                            lng: location.lng
                        };
                        saveRecentCity(currentLocation.name, currentLocation.lat, currentLocation.lng);
                        updateMapCenter();
                        await searchAllCategories();
                    } else {
                        showLocationChoices(list);
                    }
                } else {
                    alert('Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§. Îã§Î•∏ Í≤ÄÏÉâÏñ¥Î•º ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
                    setLoading(false);
                }
            } catch (error) {
                console.error('Geocoding error:', error);
                alert('Í≤ÄÏÉâ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                setLoading(false);
            }
        }

        // Get current location
        function getCurrentLocation() {
            if (!navigator.geolocation) {
                alert('Ïù¥ Î∏åÎùºÏö∞Ï†ÄÏóêÏÑúÎäî ÏúÑÏπò ÏÑúÎπÑÏä§Î•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
                return;
            }

            showLocationStatus('ÏúÑÏπòÎ•º Í∞ÄÏ†∏Ïò§Îäî Ï§ë...');
            document.getElementById('locationBtn').classList.add('active');

            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    currentLocation = {
                        name: 'ÌòÑÏû¨ ÏúÑÏπò',
                        lat: position.coords.latitude,
                        lng: position.coords.longitude
                    };

                    // Reverse geocode to get address
                    try {
                        const response = await fetch(
                            `https://maps.googleapis.com/maps/api/geocode/json?latlng=${currentLocation.lat},${currentLocation.lng}&key=${API_KEY}`
                        );
                        const data = await response.json();
                        if (data.status === 'OK' && data.results.length > 0) {
                            currentLocation.name = data.results[0].formatted_address;
                        }
                    } catch (e) {
                        console.log('Reverse geocode failed', e);
                    }

                    document.getElementById('searchInput').value = currentLocation.name;
                    hideLocationStatus();
                    document.getElementById('locationBtn').classList.remove('active');

                    // save recent city
                    saveRecentCity(currentLocation.name, currentLocation.lat, currentLocation.lng);

                    // show/update current location marker on the map
                    if (map) {
                        if (currentLocationMarker) currentLocationMarker.setMap(null);
                        currentLocationMarker = new google.maps.Marker({
                            position: { lat: currentLocation.lat, lng: currentLocation.lng },
                            map: map,
                            title: 'ÌòÑÏû¨ ÏúÑÏπò',
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 10,
                                fillColor: '#4285F4',
                                fillOpacity: 1,
                                strokeColor: '#ffffff',
                                strokeWeight: 2
                            }
                        });
                        map.setCenter({ lat: currentLocation.lat, lng: currentLocation.lng });
                        map.setZoom(radiusToZoom[currentRadius] || 12);
                    }

                    await searchAllCategories();
                },
                (error) => {
                    hideLocationStatus();
                    document.getElementById('locationBtn').classList.remove('active');
                    
                    let message = 'ÏúÑÏπòÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.';
                    if (error.code === error.PERMISSION_DENIED) {
                        message = 'ÏúÑÏπò Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§. Î∏åÎùºÏö∞Ï†Ä ÏÑ§Ï†ïÏóêÏÑú ÏúÑÏπò Í∂åÌïúÏùÑ ÌóàÏö©Ìï¥Ï£ºÏÑ∏Ïöî.';
                    }
                    alert(message);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        // Show a chooser overlay when geocode returns multiple candidates
        function showLocationChoices(results) {
            const id = 'locationChoicesOverlay';
            let ol = document.getElementById(id);
            if (ol) ol.remove();
            ol = document.createElement('div');
            ol.id = id;
            ol.style.position = 'fixed';
            ol.style.left = '0';
            ol.style.top = '0';
            ol.style.right = '0';
            ol.style.bottom = '0';
            ol.style.background = 'rgba(0,0,0,0.5)';
            ol.style.zIndex = 3000;
            ol.style.display = 'flex';
            ol.style.alignItems = 'center';
            ol.style.justifyContent = 'center';

            const box = document.createElement('div');
            box.style.width = '640px';
            box.style.maxHeight = '70vh';
            box.style.overflow = 'auto';
            box.style.background = 'var(--bg-card)';
            box.style.border = '1px solid var(--border)';
            box.style.padding = '12px';
            box.style.borderRadius = '10px';

            box.innerHTML = `<h3 style="margin-bottom:8px">Í≤ÄÏÉâ Í≤∞Í≥º Ï§ë ÏúÑÏπòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</h3>`;
            results.forEach((r, i) => {
                const p = document.createElement('div');
                p.style.padding = '10px';
                p.style.borderBottom = '1px solid var(--border)';
                p.style.cursor = 'pointer';
                p.onmouseover = () => p.style.background = 'var(--bg-hover)';
                p.onmouseout = () => p.style.background = 'transparent';
                const types = (r.types || []).slice(0,3).join(', ');
                p.innerHTML = `<div style="font-weight:700">${r.formatted_address}</div><div style="font-size:12px;color:var(--text-secondary)">${types}</div>`;
                p.onclick = async () => {
                    const loc = r.geometry.location;
                    currentLocation = { name: r.formatted_address, lat: loc.lat, lng: loc.lng };
                    document.getElementById('searchInput').value = currentLocation.name;
                    saveRecentCity(currentLocation.name, currentLocation.lat, currentLocation.lng);
                    ol.remove();
                    updateMapCenter();
                    setLoading(true);
                    try { await searchAllCategories(); } catch(e){ console.error(e); }
                    setLoading(false);
                };
                box.appendChild(p);
            });

            const cancel = document.createElement('div');
            cancel.style.marginTop = '8px';
            cancel.innerHTML = `<button class="radius-btn">Ï∑®ÏÜå</button>`;
            cancel.onclick = () => ol.remove();
            box.appendChild(cancel);

            ol.appendChild(box);
            document.body.appendChild(ol);
        }

        function showLocationStatus(text) {
            const status = document.getElementById('locationStatus');
            document.getElementById('locationStatusText').textContent = text;
            status.classList.remove('hidden');
        }

        function hideLocationStatus() {
            document.getElementById('locationStatus').classList.add('hidden');
        }

        // Update map center and zoom based on radius
        function updateMapCenter() {
            if (map && currentLocation.lat && currentLocation.lng) {
                map.setCenter({ lat: currentLocation.lat, lng: currentLocation.lng });
                map.setZoom(radiusToZoom[currentRadius] || 12);
            }
        }

        // Search all categories
        async function searchAllCategories() {
            if (!currentLocation.lat || !currentLocation.lng) return;

            setLoading(true);
            const maxCount = parseInt(document.getElementById('countSelect').value);

            try {
                // Î™®Îì† Ïπ¥ÌÖåÍ≥†Î¶¨ Î≥ëÎ†¨ Í≤ÄÏÉâ
                const [allResults, attractionResults, restaurantResults, cafeResults, lodgingResults, fineDiningResults] = await Promise.all([
                    searchPlacesByCategory('all', maxCount),
                    searchPlacesByCategory('attraction', maxCount),
                    searchPlacesByCategory('restaurant', maxCount),
                    searchPlacesByCategory('cafe', maxCount),
                    searchPlacesByCategory('lodging', maxCount),
                    searchFineDining(maxCount)
                ]);

                placesData.all = allResults;
                placesData.attraction = attractionResults;
                placesData.restaurant = restaurantResults;
                placesData.cafe = cafeResults;
                placesData.lodging = lodgingResults;
                placesData.fine_dining = fineDiningResults;

                updateCategoryCounts();
                applySortAndFilter();

            } catch (error) {
                console.error('Search error:', error);
                showError(error.message);
            } finally {
                setLoading(false);
            }
        }

        // Search places by category
        async function searchPlacesByCategory(category, maxCount) {
            const includedTypes = categoryIncludedTypes[category] || [];
            
            const requestBody = {
                locationRestriction: {
                    circle: {
                        center: { 
                            latitude: currentLocation.lat, 
                            longitude: currentLocation.lng 
                        },
                        radius: currentRadius
                    }
                },
                maxResultCount: Math.min(maxCount, 20),
                rankPreference: 'POPULARITY'
            };

            // ÌäπÏ†ï Ïπ¥ÌÖåÍ≥†Î¶¨Î©¥ ÌÉÄÏûÖ ÌïÑÌÑ∞ Ï∂îÍ∞Ä
            if (includedTypes.length > 0) {
                requestBody.includedTypes = includedTypes;
            }

            const response = await fetch('https://places.googleapis.com/v1/places:searchNearby', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Goog-Api-Key': API_KEY,
                    'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.rating,places.userRatingCount,places.priceLevel,places.types,places.photos,places.primaryType,places.location,places.currentOpeningHours'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error?.message || `API Error: ${response.status}`);
            }

            const data = await response.json();
            let places = data.places || [];
            console.debug('[PlacesAPI] category=', category, 'rawCount=', places.length);

            // Post-process: filter out obviously non-matching place types returned by the API
            function hasAnyType(place, types) {
                if (!place.types || !Array.isArray(place.types)) return false;
                for (const t of place.types) {
                    if (types.indexOf(t) !== -1) return true;
                }
                return false;
            }

            // Exclude obvious non-matching POI types that frequently pollute restaurant results
            // Note: do NOT exclude 'point_of_interest'/'establishment' globally because many valid POIs use them.
            const excludeTypes = ['shopping_mall', 'department_store', 'store', 'lodging'];

            if (includedTypes && includedTypes.length > 0) {
                places = places.filter(p => {
                    // Keep if any of the place types match requested includedTypes
                    const ok = hasAnyType(p, includedTypes) || (p.primaryType && includedTypes.indexOf(p.primaryType) !== -1);
                    if (!ok) return false;
                    // exclude obvious non-restaurant POIs even if API returned them
                    if (hasAnyType(p, excludeTypes)) return false;
                    return true;
                });
                console.debug('[PlacesAPI] category=', category, 'afterFilterCount=', places.length);
            } else if (category === 'restaurant') {
                // defensive filtering for restaurant category when includedTypes was empty
                const restaurantSeed = categoryIncludedTypes['restaurant'];
                places = places.filter(p => hasAnyType(p, restaurantSeed) && !hasAnyType(p, excludeTypes));
                console.debug('[PlacesAPI] category=restaurant afterFilterCount=', places.length);
            }

            // Review-count based sort (popularity)
            places.sort((a, b) => (b.userRatingCount || 0) - (a.userRatingCount || 0));

            return places;
        }

        // Fine dining specialized search (text query + price/rating filtering)
        async function searchFineDining(maxCount) {
            const locationName = currentLocation.name
                ? currentLocation.name.split(',')[0].trim()
                : '';
            const query = locationName ? `fine dining ${locationName}` : 'fine dining';

            const requestBody = {
                textQuery: query,
                locationBias: {
                    circle: {
                        center: {
                            latitude: currentLocation.lat,
                            longitude: currentLocation.lng
                        },
                        radius: currentRadius
                    }
                },
                maxResultCount: Math.min(maxCount, 20),
                rankPreference: 'RELEVANCE'
            };

            const response = await fetch('https://places.googleapis.com/v1/places:searchText', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Goog-Api-Key': API_KEY,
                    'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.rating,places.userRatingCount,places.priceLevel,places.types,places.photos,places.primaryType,places.location,places.currentOpeningHours'
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                console.error('Fine dining search error');
                return [];
            }

            const data = await response.json();
            let places = data.places || [];

            // $$$ / $$$$ Îßå ÌóàÏö©, Í∞ÄÍ≤© Ï†ïÎ≥¥ ÏóÜÏúºÎ©¥ Ï†úÏô∏
            const allowedPriceLevels = ['PRICE_LEVEL_EXPENSIVE', 'PRICE_LEVEL_VERY_EXPENSIVE'];
            places = places.filter(p => p.priceLevel && allowedPriceLevels.includes(p.priceLevel));

            // Î≥ÑÏ†ê ÎÇ¥Î¶ºÏ∞®Ïàú, ÎèôÏ†êÏù¥Î©¥ Í∞ÄÍ≤© ÎÜíÏùÄ Ïàú
            places.sort((a, b) => {
                const ratingDiff = (b.rating || 0) - (a.rating || 0);
                if (Math.abs(ratingDiff) > 0.05) return ratingDiff;
                return getPriceLevelNumber(b.priceLevel) - getPriceLevelNumber(a.priceLevel);
            });

            return places;
        }

        // Loading state
        function setLoading(loading) {
            isLoading = loading;
            const searchBtn = document.getElementById('searchBtn');
            const locationBtn = document.getElementById('locationBtn');
            
            searchBtn.disabled = loading;
            locationBtn.disabled = loading;
            searchBtn.textContent = loading ? 'Í≤ÄÏÉâ Ï§ë...' : 'Í≤ÄÏÉâ';

            if (loading) {
                showSkeletonLoading();
            }
        }

        function showSkeletonLoading() {
            const grid = document.getElementById('placesGrid');
            const skeletons = Array(6).fill(0).map(() => `
                <div class="skeleton-card">
                    <div class="skeleton-image"></div>
                    <div class="skeleton-content">
                        <div class="skeleton-line medium"></div>
                        <div class="skeleton-line short"></div>
                        <div class="skeleton-line"></div>
                    </div>
                </div>
            `).join('');
            grid.innerHTML = skeletons;
        }

        function showError(message) {
            const grid = document.getElementById('placesGrid');
            grid.innerHTML = `
                <div class="error-banner">
                    <span class="error-banner-icon">‚ö†Ô∏è</span>
                    <div class="error-banner-content">
                        <div class="error-banner-title">Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§</div>
                        <div class="error-banner-text">${message}</div>
                    </div>
                </div>
            `;
            document.getElementById('resultsTitle').textContent = 'Ïò§Î•ò Î∞úÏÉù';
            document.getElementById('resultsCount').textContent = '';
        }

        // Category counts
        function updateCategoryCounts() {
            document.getElementById('count-all').textContent = placesData.all.length;
            document.getElementById('count-attraction').textContent = placesData.attraction.length;
            document.getElementById('count-restaurant').textContent = placesData.restaurant.length;
            document.getElementById('count-cafe').textContent = placesData.cafe.length;
            document.getElementById('count-lodging').textContent = placesData.lodging.length;
            // fine-dining count: use scoring function to better surface quality restaurants
            // fine_dining count reflects the separate fine_dining search results (price-filtered)
            document.getElementById('count-fine-dining').textContent = (placesData.fine_dining || []).length;
        }

        function updateFavoritesCount() {
            document.getElementById('count-favorites').textContent = favorites.length;
        }

        // Sort and filter
        function applySortAndFilter() {
            const sortBy = document.getElementById('sortSelect').value;
            
            // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Îç∞Ïù¥ÌÑ∞ ÏÑ†ÌÉù
            if (currentCategory === 'favorites') {
                filteredPlaces = [...favorites];
            } else if (currentCategory === 'fine_dining') {
                // ÌååÏù∏Îã§Ïù¥Îãù: use dedicated fine_dining search results (already price-filtered)
                filteredPlaces = [...(placesData.fine_dining || [])];
                // Í∞ÄÍ≤© ÌïÑÌÑ∞Îßå Ï†ÅÏö© (Ï†ïÎ†¨ÏùÄ ÌååÏù∏Îã§Ïù¥Îãù Ï†ÑÏö©ÏúºÎ°ú Ï≤òÎ¶¨)
                if (currentPriceFilter !== 'all') {
                    const targetPrice = parseInt(currentPriceFilter);
                    filteredPlaces = filteredPlaces.filter(p => getPriceLevelNumber(p.priceLevel) === targetPrice);
                }
                // sort by rating desc, tie-breaker: price desc
                filteredPlaces.sort((a, b) => {
                    const r = (b.rating || 0) - (a.rating || 0);
                    if (r !== 0) return r;
                    return getPriceLevelNumber(b.priceLevel) - getPriceLevelNumber(a.priceLevel);
                });
                renderPlaces();
                updateMarkers();
                return;
            } else {
                filteredPlaces = [...(placesData[currentCategory] || [])];
            }

            // Í∞ÄÍ≤© ÌïÑÌÑ∞
            if (currentPriceFilter !== 'all') {
                const targetPrice = parseInt(currentPriceFilter);
                filteredPlaces = filteredPlaces.filter(p => {
                    const level = getPriceLevelNumber(p.priceLevel);
                    return level === targetPrice;
                });
            }

            // If on favorites tab, show note under address

            // Ï†ïÎ†¨
            filteredPlaces.sort((a, b) => {
                switch (sortBy) {
                    case 'reviews':
                        return (b.userRatingCount || 0) - (a.userRatingCount || 0);
                    case 'rating':
                        return (b.rating || 0) - (a.rating || 0);
                    case 'price_low':
                        return getPriceLevelNumber(a.priceLevel) - getPriceLevelNumber(b.priceLevel);
                    case 'price_high':
                        return getPriceLevelNumber(b.priceLevel) - getPriceLevelNumber(a.priceLevel);
                    default:
                        return 0;
                }
            });

            renderPlaces();
            updateMarkers();
        }

        function getPriceLevelNumber(priceLevel) {
            const mapping = {
                'PRICE_LEVEL_FREE': 0,
                'PRICE_LEVEL_INEXPENSIVE': 1,
                'PRICE_LEVEL_MODERATE': 2,
                'PRICE_LEVEL_EXPENSIVE': 3,
                'PRICE_LEVEL_VERY_EXPENSIVE': 4
            };
            return mapping[priceLevel] ?? -1; // -1 for unknown
        }

        

        // Render places
        function renderPlaces() {
            const grid = document.getElementById('placesGrid');
            const title = document.getElementById('resultsTitle');
            const count = document.getElementById('resultsCount');
            const apiNote = document.getElementById('apiLimitNote');

            const categoryNames = {
                all: 'Ï†ÑÏ≤¥',
                attraction: 'Í¥ÄÍ¥ëÏßÄ¬∑Î™ÖÏÜå',
                restaurant: 'ÏùåÏãùÏ†ê',
                cafe: 'Ïπ¥Ìéò¬∑Î∞î',
                fine_dining: 'ÌååÏù∏Îã§Ïù¥Îãù',
                favorites: 'Ï¶êÍ≤®Ï∞æÍ∏∞'
            };

            const locationName = currentLocation.name ? 
                currentLocation.name.split(',')[0] : 'Í≤ÄÏÉâ Í≤∞Í≥º';
            
            title.textContent = `${locationName} - ${categoryNames[currentCategory]}`;
            count.textContent = `${filteredPlaces.length}Í∞ú Ïû•ÏÜå`;
            
            // API Ï†úÌïú ÏïàÎÇ¥
            const maxCount = parseInt(document.getElementById('countSelect').value);
            apiNote.style.display = (maxCount > 20 && currentCategory !== 'favorites') ? 'inline' : 'none';

            if (filteredPlaces.length === 0) {
                const isFavorites = currentCategory === 'favorites';
                const isFiltered = currentPriceFilter !== 'all';
                
                grid.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">${isFavorites ? 'üíî' : isFiltered ? 'üîç' : 'üìç'}</div>
                        <h3 class="empty-title">${
                            isFavorites ? 'Ï¶êÍ≤®Ï∞æÍ∏∞Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§' : 
                            isFiltered ? 'ÌïÑÌÑ∞ Ï°∞Í±¥Ïóê ÎßûÎäî Ïû•ÏÜåÍ∞Ä ÏóÜÏäµÎãàÎã§' :
                            'Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§'
                        }</h3>
                        <p class="empty-text">${
                            isFavorites ? 'ÎßàÏùåÏóê ÎìúÎäî Ïû•ÏÜåÎ•º ‚ô• Î≤ÑÌäºÏúºÎ°ú Ï†ÄÏû•ÌïòÏÑ∏Ïöî' :
                            isFiltered ? 'Îã§Î•∏ Í∞ÄÍ≤©ÎåÄÎ•º ÏÑ†ÌÉùÌï¥Î≥¥ÏÑ∏Ïöî' :
                            'Îã§Î•∏ ÏúÑÏπòÎÇò Î∞òÍ≤ΩÏùÑ ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî'
                        }</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = filteredPlaces.map((place, index) => {
                const photoUrl = getPhotoUrl(place);
                const isFavorite = favorites.some(f => f.id === place.id);
                const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
                const typeLabel = getTypeLabel(place.types);
                const priceDisplay = getPriceDisplay(place.priceLevel);
                const open = getOpenStatus(place);

                return `
                    <div class="place-card fade-in" 
                         style="animation-delay: ${index * 0.03}s"
                         data-place-id="${place.id}"
                         onmouseenter="highlightMarker('${place.id}')"
                         onmouseleave="unhighlightMarker('${place.id}')"
                         onclick="openGoogleMaps('${encodeURIComponent(place.displayName?.text || '')}', ${place.location?.latitude || 0}, ${place.location?.longitude || 0}, '${place.id || ''}')">
                        <div class="place-image-container">
                            ${photoUrl 
                                ? `<img src="${photoUrl}" alt="${place.displayName?.text || ''}" class="place-image" loading="lazy" onerror="this.parentElement.innerHTML='<div class=\\'no-image\\'>üìç</div>'">`
                                : `<div class="no-image">üìç</div>`
                            }
                                <div class="place-rank ${rankClass}">${index + 1}</div>
                                <div style="position:absolute;right:8px;top:8px;background:rgba(0,0,0,0.6);color:white;padding:4px 8px;border-radius:8px;font-size:12px">${open.color} ${open.text}</div>
                                    <button class="favorite-btn ${isFavorite ? 'active' : ''}" onclick="event.stopPropagation(); toggleFavorite('${place.id}', this)" title="Ï¶êÍ≤®Ï∞æÍ∏∞">
                                        ${isFavorite ? '‚ù§Ô∏è' : 'ü§ç'}
                                    </button>
                                    ${isFavorite ? `<button class="radius-btn" style="position:absolute;right:8px;bottom:8px;padding:6px;font-size:12px;" onclick="event.stopPropagation(); editFavoriteNote('${place.id}')">‚úèÔ∏è Î©îÎ™®</button>` : ''}
                            <div class="place-type-badge">${typeLabel}</div>
                        </div>
                        <div class="place-content">
                            <h3 class="place-name">${place.displayName?.text || 'Ïù¥Î¶Ñ ÏóÜÏùå'}</h3>
                                        <p class="place-address">${place.formattedAddress || 'Ï£ºÏÜå Ï†ïÎ≥¥ ÏóÜÏùå'}</p>
                                        ${isFavorite && (place.note || '') ? `<p style="color:var(--text-secondary);font-size:12px;margin-top:6px">Î©îÎ™®: ${place.note}</p>` : ''}
                            <div class="place-stats">
                                <div class="stat">
                                    <span class="stat-icon">üí¨</span>
                                    <span class="stat-value reviews">${formatNumber(place.userRatingCount || 0)}</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-icon">‚≠ê</span>
                                    <span class="stat-value rating">${place.rating?.toFixed(1) || '-'}</span>
                                </div>
                                <div class="stat">
                                    <span class="stat-icon">üí∞</span>
                                    <span class="stat-value price">${priceDisplay}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getPhotoUrl(place) {
            if (!place.photos || !place.photos[0]?.name) return null;
            return `https://places.googleapis.com/v1/${place.photos[0].name}/media?maxHeightPx=400&maxWidthPx=400&key=${API_KEY}`;
        }

        // Determine open status badge text and color
        function getOpenStatus(place) {
            try {
                // prefer currentOpeningHours if available
                const cur = place.currentOpeningHours;
                if (cur && typeof cur.openNow === 'boolean') {
                    // check for nextClose or nextUpdateTime to determine "Í≥ß ÎßàÍ∞ê"
                    if (cur.openNow) {
                        // if nextClose provided as ISO string, compute minutes left
                        const nextClose = cur.nextClose || cur.nextClosingTime || cur.nextCloseTime;
                        if (nextClose) {
                            const ms = Date.parse(nextClose) - Date.now();
                            const mins = Math.round(ms / 60000);
                            if (mins > 0 && mins <= 60) return { text: `Í≥ß ÎßàÍ∞ê (${mins}Î∂Ñ)`, color: 'üü°' };
                        }
                        return { text: 'ÏòÅÏóÖ Ï§ë', color: 'üü¢' };
                    }
                    return { text: 'ÏòÅÏóÖ Ï¢ÖÎ£å', color: 'üî¥' };
                }

                // fallback to openingHours with simple flags
                const oh = place.openingHours;
                if (oh && typeof oh.openNow === 'boolean') {
                    if (oh.openNow) return { text: 'ÏòÅÏóÖ Ï§ë', color: 'üü¢' };
                    return { text: 'ÏòÅÏóÖ Ï¢ÖÎ£å', color: 'üî¥' };
                }
            } catch (e) {
                // ignore
            }
            return { text: 'ÏòÅÏóÖ Ï†ïÎ≥¥ ÏóÜÏùå', color: '‚ö™' };
        }

        function getTypeLabel(types) {
            if (!types || types.length === 0) return 'Ïû•ÏÜå';
            for (const type of types) {
                if (typeLabels[type]) return typeLabels[type];
            }
            return 'Ïû•ÏÜå';
        }

        function getPriceDisplay(priceLevel) {
            const mapping = {
                'PRICE_LEVEL_FREE': 'Î¨¥Î£å',
                'PRICE_LEVEL_INEXPENSIVE': '$',
                'PRICE_LEVEL_MODERATE': '$$',
                'PRICE_LEVEL_EXPENSIVE': '$$$',
                'PRICE_LEVEL_VERY_EXPENSIVE': '$$$$'
            };
            return mapping[priceLevel] || '-';
        }

        function formatNumber(num) {
            if (num >= 10000) return (num / 10000).toFixed(1) + 'Îßå';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toLocaleString();
        }

        // Map markers
        function updateMarkers() {
            // Clear existing markers
            markers.forEach(m => m.setMap(null));
            markers = [];

            if (!map) return;

            // Add new markers
            filteredPlaces.forEach((place, index) => {
                if (!place.location) return;

                const marker = new google.maps.Marker({
                    position: { 
                        lat: place.location.latitude, 
                        lng: place.location.longitude 
                    },
                    map: map,
                    label: {
                        text: String(index + 1),
                        color: 'white',
                        fontWeight: 'bold',
                        fontSize: '11px'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 14,
                        fillColor: index < 3 ? '#f59e0b' : '#6366f1',
                        fillOpacity: 1,
                        strokeColor: 'white',
                        strokeWeight: 2
                    }
                });

                marker.placeId = place.id;
                marker.placeIndex = index;

                marker.addListener('click', () => {
                    infoWindow.setContent(`
                        <div style="padding: 8px; max-width: 220px; font-family: 'Noto Sans KR', sans-serif;">
                            <div style="font-weight: 700; font-size: 14px; margin-bottom: 4px;">${place.displayName?.text || 'Ïù¥Î¶Ñ ÏóÜÏùå'}</div>
                            <div style="font-size: 12px; color: #666;">
                                ‚≠ê ${place.rating?.toFixed(1) || '-'} ¬∑ üí¨ ${formatNumber(place.userRatingCount || 0)} Î¶¨Î∑∞
                            </div>
                        </div>
                    `);
                    infoWindow.open(map, marker);

                    // Scroll to card
                    const card = document.querySelector(`[data-place-id="${place.id}"]`);
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        card.classList.add('highlighted');
                        setTimeout(() => card.classList.remove('highlighted'), 2000);
                    }
                });

                markers.push(marker);
            });

            // Fit bounds if has markers
            if (markers.length > 1) {
                const bounds = new google.maps.LatLngBounds();
                markers.forEach(m => bounds.extend(m.getPosition()));
                map.fitBounds(bounds, { padding: 50 });
            } else if (markers.length === 1) {
                map.setCenter(markers[0].getPosition());
                map.setZoom(radiusToZoom[currentRadius] || 12);
            }
        }

        function highlightMarker(placeId) {
            const markerIndex = markers.findIndex(m => m.placeId === placeId);
            const marker = markers[markerIndex];
            if (marker) {
                marker.setIcon({
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 18,
                    fillColor: '#ef4444',
                    fillOpacity: 1,
                    strokeColor: 'white',
                    strokeWeight: 3
                });
                marker.setZIndex(1000);
            }
        }

        function unhighlightMarker(placeId) {
            const markerIndex = markers.findIndex(m => m.placeId === placeId);
            const marker = markers[markerIndex];
            if (marker) {
                const index = marker.placeIndex;
                marker.setIcon({
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 14,
                    fillColor: index < 3 ? '#f59e0b' : '#6366f1',
                    fillOpacity: 1,
                    strokeColor: 'white',
                    strokeWeight: 2
                });
                marker.setZIndex(undefined);
            }
        }

        // Open Google Maps
        function openGoogleMaps(name, lat, lng, placeId) {
            let url;
            if (placeId) {
                // Place IDÍ∞Ä ÏûàÏúºÎ©¥ Ï†ïÌôïÌïú Ïû•ÏÜåÎ°ú ÏßÅÏ†ë Ïó∞Í≤∞
                url = `https://www.google.com/maps/search/?api=1&query=${name}&query_place_id=${placeId}`;
            } else {
                url = `https://www.google.com/maps/search/?api=1&query=${name}&query=${lat},${lng}`;
            }
            window.open(url, '_blank');
        }

        // Favorites
        function toggleFavorite(placeId, btnElement) {
            const existingIndex = favorites.findIndex(f => f.id === placeId);
            
            if (existingIndex === -1) {
                // Add to favorites - find the place data
                let place = null;
                for (const category of Object.values(placesData)) {
                    place = category.find(p => p.id === placeId);
                    if (place) break;
                }
                
                if (place) {
                    const toSave = { ...place, note: '' };
                    favorites.push(toSave); // Store full data; editing via editFavoriteNote()
                }
            } else {
                favorites.splice(existingIndex, 1);
            }
            
            localStorage.setItem('favorites_v2', JSON.stringify(favorites));
            updateFavoritesCount();
            
            // Update button
            if (btnElement) {
                const isFavorite = favorites.some(f => f.id === placeId);
                btnElement.classList.toggle('active', isFavorite);
                btnElement.textContent = isFavorite ? '‚ù§Ô∏è' : 'ü§ç';
            }

            // Re-render if on favorites tab
            if (currentCategory === 'favorites') {
                applySortAndFilter();
            }
        }

        function editFavoriteNote(placeId) {
            const idx = favorites.findIndex(f => f.id === placeId);
            if (idx === -1) return alert('Ï¶êÍ≤®Ï∞æÍ∏∞ Ìï≠Î™©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
            const current = favorites[idx].note || '';
            const updated = prompt('Ï¶êÍ≤®Ï∞æÍ∏∞ Î©îÎ™® Ìé∏Ïßë:', current);
            if (updated === null) return; // cancel
            favorites[idx].note = updated.slice(0, 200);
            localStorage.setItem('favorites_v2', JSON.stringify(favorites));
            if (currentCategory === 'favorites') applySortAndFilter();
            // also re-render cards to show note
            renderPlaces();
        }

        // Controls
        async function setRadius(radius) {
            currentRadius = radius;
            syncRadiusUI(radius);
            document.querySelectorAll('.radius-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.radius) === radius);
            });

            // Update map zoom
            if (map && currentLocation.lat) {
                map.setZoom(radiusToZoom[radius] || 12);
            }

            // Clear previous results to avoid showing stale data while new search runs
            placesData = { all: [], attraction: [], restaurant: [], cafe: [], lodging: [], fine_dining: [] };
            updateCategoryCounts();
            showSkeletonLoading();

            // Always re-search when radius changes (debounced briefly to avoid rapid repeats)
            try {
                if (currentLocation.lat && currentLocation.lng) {
                    await searchAllCategories();
                }
            } catch (e) {
                console.error('setRadius search failed', e);
            }
        }

        // keep UI (range input and label) in sync with currentRadius
        function syncRadiusUI(radius) {
            const range = document.getElementById('radiusRange');
            const val = document.getElementById('radiusValue');
            // find nearest index for given radius
            let index = radiusSteps.findIndex(r => r === radius);
            if (index === -1) {
                index = radiusSteps.findIndex(r => r >= radius);
                if (index === -1) index = radiusSteps.length - 1;
            }
            if (range) range.value = index;
            if (val) {
                const r = radiusSteps[index];
                val.textContent = r >= 1000 ? (r / 1000) + 'km' : r + 'm';
            }
        }

        function changeRadiusStep(delta) {
            const curIndex = radiusSteps.findIndex(r => r === currentRadius);
            const index = curIndex === -1 ? radiusSteps.findIndex(r => r >= currentRadius) : curIndex;
            let next = (index === -1 ? 0 : index) + delta;
            next = Math.max(0, Math.min(next, radiusSteps.length - 1));
            const r = radiusSteps[next];
            if (r && r !== currentRadius) setRadius(r);
        }

        function setCategory(category) {
            currentCategory = category;
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.category === category);
            });
            applySortAndFilter();
        }

        // Recent cities helpers
        function saveRecentCity(name, lat, lng) {
            if (!name) return;
            // keep unique, most-recent-first, max 12
            recentCities = recentCities.filter(c => c.name !== name);
            recentCities.unshift({ name, lat, lng, ts: Date.now() });
            if (recentCities.length > 12) recentCities.length = 12;
            localStorage.setItem('recentCities_v1', JSON.stringify(recentCities));
            populateRecentCitiesDatalist();
        }

        function populateRecentCitiesDatalist() {
            const dl = document.getElementById('recentCitiesList');
            if (!dl) return;
            dl.innerHTML = recentCities.map(c => `<option value="${c.name}"></option>`).join('');
        }

        populateRecentCitiesDatalist();

        function populateRecentQueriesDatalist() {
            const dl = document.getElementById('recentQueriesList');
            if (!dl) return;
            dl.innerHTML = recentQueries.map(q => `<option value="${q}"></option>`).join('');
        }

        populateRecentQueriesDatalist();

        // Custom text search
        async function handleCustomSearch() {
            const q = document.getElementById('customQuery').value.trim();
            if (!q) return alert('Í≤ÄÏÉâÏñ¥Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
            setLoading(true);
            try {
                // save recent query (unique, most recent first)
                recentQueries = recentQueries.filter(x => x !== q);
                recentQueries.unshift(q);
                if (recentQueries.length > 12) recentQueries.length = 12;
                localStorage.setItem('recentQueries_v1', JSON.stringify(recentQueries));
                populateRecentQueriesDatalist();
                const maxCount = parseInt(document.getElementById('countSelect').value);
                const data = await searchPlacesByTextQuery(q, maxCount);
                // put results into a temporary category and render
                placesData.all = data;
                currentCategory = 'all';
                updateCategoryCounts();
                applySortAndFilter();
            } catch (e) {
                console.error(e);
                showError(e.message);
            } finally {
                setLoading(false);
            }
        }

        async function searchPlacesByTextQuery(query, maxCount) {
            const request = {
                query: query,
                locationRestriction: {
                    circle: {
                        center: { latitude: currentLocation.lat, longitude: currentLocation.lng },
                        radius: currentRadius
                    }
                },
                maxResultCount: Math.min(maxCount, 20),
                rankPreference: 'RELEVANCE'
            };

            const resp = await fetch('https://places.googleapis.com/v1/places:searchText', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Goog-Api-Key': API_KEY,
                    'X-Goog-FieldMask': 'places.id,places.displayName,places.formattedAddress,places.rating,places.userRatingCount,places.priceLevel,places.types,places.photos,places.primaryType,places.location,places.currentOpeningHours'
                },
                body: JSON.stringify(request)
            });

            if (!resp.ok) {
                const j = await resp.json();
                throw new Error(j.error?.message || 'Text search failed');
            }
            const j = await resp.json();
            return j.places || [];
        }

        // Compare UI (simple): prompt for second city, run fine_dining text search for both and show counts
        async function openCompareUI() {
            const cityA = document.getElementById('searchInput').value.trim();
            if (!cityA) return alert('ÎπÑÍµêÌï† Ï≤´ ÎèÑÏãúÎ•º Í≤ÄÏÉâ ÏûÖÎ†•ÌïòÏÑ∏Ïöî');
            const cityB = prompt('ÎπÑÍµêÌï† ÎëêÎ≤àÏß∏ ÎèÑÏãúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî (Ïòà: Tokyo)');
            if (!cityB) return;
            setLoading(true);
            try {
                const coordsA = { lat: currentLocation.lat, lng: currentLocation.lng };
                // geocode B
                const geo = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(cityB)}&key=${API_KEY}`);
                const geoJ = await geo.json();
                if (geoJ.status !== 'OK' || !geoJ.results.length) throw new Error('ÎëêÎ≤àÏß∏ ÎèÑÏãúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
                const locB = geoJ.results[0].geometry.location;

                // run fine dining text search for both
                const fdA = await searchPlacesByTextQuery(`fine dining ${cityA}`, 20);
                const fdB = await searchPlacesByTextQuery(`fine dining ${cityB}`, 20);

                // prepare simple stats
                const statsA = summarizePlaces(fdA);
                const statsB = summarizePlaces(fdB);

                // keep last results for CSV/export
                window._lastCompareA = fdA;
                window._lastCompareB = fdB;
                showCompareOverlay(cityA, statsA, cityB, statsB, fdA, fdB);
            } catch (e) {
                console.error(e);
                alert(e.message || 'ÎπÑÍµê Ïã§Ìå®');
            } finally {
                setLoading(false);
            }
        }

        function summarizePlaces(list) {
            const count = list.length;
            const avgRating = (list.reduce((s,p)=>s+(p.rating||0),0) / Math.max(1, count)).toFixed(2);
            return { count, avgRating };
        }

        function showCompareOverlay(aName, aStats, bName, bStats, listA = [], listB = []) {
            const overlayId = 'compareOverlay';
            let ol = document.getElementById(overlayId);
            if (!ol) {
                ol = document.createElement('div');
                ol.id = overlayId;
                ol.style.position = 'fixed';
                ol.style.left = '10%';
                ol.style.top = '10%';
                ol.style.width = '80%';
                ol.style.height = '80%';
                ol.style.background = 'var(--bg-card)';
                ol.style.border = '1px solid var(--border)';
                ol.style.zIndex = 2000;
                ol.style.padding = '16px';
                ol.style.overflow = 'auto';
                document.body.appendChild(ol);
            }
            // top lists and CSV export
            const topA = (listA || []).slice(0,10).map(p=>p.displayName?.text||p.name||'Ïù¥Î¶Ñ').join('\n');
            const topB = (listB || []).slice(0,10).map(p=>p.displayName?.text||p.name||'Ïù¥Î¶Ñ').join('\n');
            ol.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px"><h3>ÎèÑÏãú ÎπÑÍµê</h3><div><button onclick="downloadCompareCSV('${encodeURIComponent(aName)}','${encodeURIComponent(bName)}')" class="radius-btn">CSV ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button> <button onclick="document.getElementById('compareOverlay').remove()">Îã´Í∏∞</button></div></div>
                <div style="display:flex;gap:12px">
                    <div style="flex:1;padding:12px;border:1px solid var(--border);border-radius:8px">
                        <h4>${aName}</h4>
                        <p>ÌååÏù∏Îã§Ïù¥Îãù Ïàò: <strong>${aStats.count}</strong></p>
                        <p>ÌèâÍ∑† ÌèâÏ†ê: <strong>${aStats.avgRating}</strong></p>
                        <pre style="white-space:pre-wrap;margin-top:8px;max-height:300px;overflow:auto">${topA}</pre>
                    </div>
                    <div style="flex:1;padding:12px;border:1px solid var(--border);border-radius:8px">
                        <h4>${bName}</h4>
                        <p>ÌååÏù∏Îã§Ïù¥Îãù Ïàò: <strong>${bStats.count}</strong></p>
                        <p>ÌèâÍ∑† ÌèâÏ†ê: <strong>${bStats.avgRating}</strong></p>
                        <pre style="white-space:pre-wrap;margin-top:8px;max-height:300px;overflow:auto">${topB}</pre>
                    </div>
                </div>`;
        }

        function downloadCompareCSV(aName, bName) {
            // retrieve lists from last compare call by reading fd results previously stored as globals (if any)
            // we'll use placesData.fine_dining as fallback for left side
            const listA = window._lastCompareA || placesData.fine_dining || [];
            const listB = window._lastCompareB || [];
            const rows = [];
            const max = Math.max(listA.length, listB.length);
            for (let i=0;i<max;i++) {
                const a = listA[i];
                const b = listB[i];
                rows.push([a ? (a.displayName?.text||a.name) : '', a ? (a.formattedAddress||'') : '', b ? (b.displayName?.text||b.name) : '', b ? (b.formattedAddress||'') : '']);
            }
            let csv = `"${decodeURIComponent(aName)} - ${decodeURIComponent(bName)} ÎπÑÍµê"\n"A Ïù¥Î¶Ñ","A Ï£ºÏÜå","B Ïù¥Î¶Ñ","B Ï£ºÏÜå"\n`;
            rows.forEach(r=> { csv += `${r.map(c=>`"${(c||'').replace(/"/g,'""') }"`).join(',')}\n`; });
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'compare.csv'; a.click(); URL.revokeObjectURL(url);
        }

        // Planner UI
        function openPlanner() {
            const id = 'plannerPanel';
            if (document.getElementById(id)) return; // already open
            const p = document.createElement('div');
            p.id = id;
            p.style.position = 'fixed';
            p.style.right = '12px';
            p.style.bottom = '12px';
            p.style.width = '420px';
            p.style.height = '520px';
            p.style.background = 'var(--bg-card)';
            p.style.border = '1px solid var(--border)';
            p.style.zIndex = 2000;
            p.style.padding = '12px';
            p.style.overflow = 'auto';

            p.innerHTML = `
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <h4>Îç∞Ïù¥ ÌîåÎûòÎÑà</h4>
                    <div>
                        <button onclick="addPlannerDay()" class="radius-btn">Ïùº Ï∂îÍ∞Ä</button>
                        <button onclick="closePlanner()" class="radius-btn">Îã´Í∏∞</button>
                    </div>
                </div>
                <div id="plannerDaysContainer"></div>
            `;
            document.body.appendChild(p);
            renderPlanner();
        }

        function closePlanner() { const el = document.getElementById('plannerPanel'); if (el) el.remove(); }

        function addPlannerDay() { planner.days.push([]); savePlanner(); renderPlanner(); }

        function savePlanner() { localStorage.setItem('itinerary_v1', JSON.stringify(planner)); }

        function renderPlanner() {
            const cont = document.getElementById('plannerDaysContainer');
            cont.innerHTML = '';
            planner.days.forEach((day, idx) => {
                const div = document.createElement('div');
                div.style.border = '1px solid var(--border)';
                div.style.padding = '8px';
                div.style.marginBottom = '8px';
                div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px"><strong>Day ${idx+1}</strong><div><button onclick="computePlannerDay(${idx})" class="radius-btn">ÏãúÍ∞ÑÍ≥ÑÏÇ∞</button><button onclick="planner.days.splice(${idx},1); savePlanner(); renderPlanner();" class="radius-btn">ÏÇ≠Ï†ú</button></div></div><div id="day-${idx}" style="min-height:60px;padding:6px;border-radius:6px;background:var(--bg-hover)"></div><div id="day-${idx}-meta" style="margin-top:6px;color:var(--text-secondary)"></div>`;
                cont.appendChild(div);

                const drop = div.querySelector(`#day-${idx}`);
                drop.ondragover = (e) => e.preventDefault();
                drop.ondrop = (e) => {
                    e.preventDefault();
                    const pid = e.dataTransfer.getData('text/plain');
                    if (!pid) return;
                    // find place object from placesData or favorites
                    let place = null;
                    for (const col of Object.values(placesData)) { place = col.find(p=>p.id===pid); if (place) break; }
                    if (!place) place = favorites.find(f=>f.id===pid);
                    if (!place) return;
                        // if drop target is a timeslot, assign to specific slot
                        const slotEl = e.target.closest('[data-slot-index]');
                        if (slotEl) {
                            const slotIndex = parseInt(slotEl.dataset.slotIndex);
                            planner.days[idx][slotIndex] = place.id; // assign to slot
                        } else {
                            planner.days[idx].push(place.id);
                        }
                        savePlanner();
                        renderPlanner();
                };

                // render items as time slots (09:00-17:00, 9 slots)
                const listEl = div.querySelector(`#day-${idx}`);
                listEl.innerHTML = '';
                if (!Array.isArray(planner.days[idx]) || planner.days[idx].length === 0) {
                    planner.days[idx] = Array(9).fill(null);
                }
                const startHour = 9;
                for (let slotIndex = 0; slotIndex < planner.days[idx].length; slotIndex++) {
                    const slotDiv = document.createElement('div');
                    slotDiv.dataset.slotIndex = slotIndex;
                    slotDiv.style.padding = '6px';
                    slotDiv.style.marginBottom = '6px';
                    slotDiv.style.border = '1px dashed var(--border)';
                    slotDiv.style.minHeight = '48px';
                    slotDiv.style.display = 'flex';
                    slotDiv.style.alignItems = 'center';
                    slotDiv.style.gap = '8px';
                    slotDiv.ondragover = (e) => e.preventDefault();
                    slotDiv.ondrop = (e) => {
                        e.preventDefault();
                        const pid = e.dataTransfer.getData('text/plain');
                        if (!pid) return;
                        let place = null;
                        for (const col of Object.values(placesData)) { place = col.find(p=>p.id===pid); if (place) break; }
                        if (!place) place = favorites.find(f=>f.id===pid);
                        if (!place) return;
                        planner.days[idx][slotIndex] = place.id;
                        savePlanner(); renderPlanner();
                    };

                    const timeLabel = document.createElement('div');
                    timeLabel.style.width = '64px';
                    timeLabel.style.fontSize = '12px';
                    timeLabel.style.color = 'var(--text-secondary)';
                    timeLabel.textContent = `${(startHour + slotIndex).toString().padStart(2,'0')}:00`;
                    slotDiv.appendChild(timeLabel);

                    const pid = planner.days[idx][slotIndex];
                    if (pid) {
                        let place = null;
                        for (const col of Object.values(placesData)) { place = col.find(p=>p.id===pid); if (place) break; }
                        if (!place) place = favorites.find(f=>f.id===pid);
                        if (place) {
                            const item = document.createElement('div');
                            item.style.flex = '1';
                            item.style.padding = '6px';
                            item.style.background = 'var(--bg-card)';
                            item.style.border = '1px solid var(--border)';
                            item.draggable = true;
                            item.ondragstart = (ev)=> { ev.dataTransfer.setData('text/plain', pid); };
                            item.innerHTML = `<strong style="font-size:13px">${place.displayName?.text||place.name||'Ïù¥Î¶Ñ'}</strong><div style="font-size:12px;color:var(--text-secondary)">${place.formattedAddress||''}</div>`;
                            const del = document.createElement('button'); del.textContent='ÏÇ≠Ï†ú'; del.className='radius-btn'; del.style.marginLeft='8px'; del.onclick=()=>{ planner.days[idx][slotIndex]=null; savePlanner(); renderPlanner(); };
                            item.appendChild(del);
                            slotDiv.appendChild(item);
                        }
                    } else {
                        const hint = document.createElement('div');
                        hint.style.flex = '1';
                        hint.style.color = 'var(--text-muted)';
                        hint.textContent = 'ÎìúÎûòÍ∑∏ÌïòÏó¨ Ïû•ÏÜå Ï∂îÍ∞Ä';
                        slotDiv.appendChild(hint);
                    }

                    listEl.appendChild(slotDiv);
                }
            });
        }

        async function computePlannerDay(idx) {
            const validIds = (planner.days[idx] || []).filter(Boolean);
            if (validIds.length < 2) return alert('Îëê Í∞ú Ïù¥ÏÉÅÏùò Ïû•ÏÜåÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§');
            // build sequential legs from valid ids
            const stops = validIds.map(id => {
                let place = null;
                for (const col of Object.values(placesData)) { place = col.find(p=>p.id===id); if (place) break; }
                if (!place) place = favorites.find(f=>f.id===id);
                return place;
            }).filter(Boolean);

            let totalMeters = 0; let totalSeconds = 0;
            for (let i=0;i<stops.length-1;i++) {
                const a = stops[i].location; const b = stops[i+1].location;
                if (!a || !b) continue;
                try {
                    const key = `${a.latitude},${a.longitude}|${b.latitude},${b.longitude}`;
                    if (distanceCache[key]) {
                        totalMeters += distanceCache[key].distance || 0;
                        totalSeconds += distanceCache[key].duration || 0;
                    } else {
                        const dm = await fetch(`https://maps.googleapis.com/maps/api/distancematrix/json?origins=${a.latitude},${a.longitude}&destinations=${b.latitude},${b.longitude}&mode=driving&key=${API_KEY}`);
                        const jm = await dm.json();
                        const el = jm.rows?.[0]?.elements?.[0];
                        if (el && el.status === 'OK') {
                            const d = el.distance?.value || 0;
                            const t = el.duration?.value || 0;
                            distanceCache[key] = { distance: d, duration: t };
                            totalMeters += d;
                            totalSeconds += t;
                        }
                    }
                } catch (e) { console.warn('DistanceMatrix failed', e); }
            }
            const meta = document.getElementById(`day-${idx}-meta`);
            if (meta) meta.textContent = `Ï¥ù Ïù¥ÎèôÍ±∞Î¶¨: ${Math.round(totalMeters/1000*10)/10} km ¬∑ ÏòàÏÉÅ ÏÜåÏöîÏãúÍ∞Ñ: ${Math.round(totalSeconds/60)} Î∂Ñ`;
        }

        function togglePrice(price) {
            currentPriceFilter = price;
            document.querySelectorAll('.price-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.price === price);
            });
            applySortAndFilter();
        }

        // Theme
        function toggleTheme() {
            document.body.classList.toggle('light-mode');
            const isLight = document.body.classList.contains('light-mode');
            document.getElementById('themeToggle').textContent = isLight ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
            
            if (map) {
                map.setOptions({ styles: getMapStyles() });
            }
        }

        // Initialize theme from localStorage
        if (localStorage.getItem('theme') === 'light') {
            document.body.classList.add('light-mode');
            document.getElementById('themeToggle').textContent = '‚òÄÔ∏è';
        }

        // Enter key search
        document.getElementById('searchInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !isLoading) {
                handleSearch();
            }
        });

        // Radius range control binding
        const radiusRangeEl = document.getElementById('radiusRange');
        if (radiusRangeEl) {
            radiusRangeEl.addEventListener('input', (e) => {
                const idx = parseInt(e.target.value);
                const r = radiusSteps[idx] || currentRadius;
                const val = document.getElementById('radiusValue');
                if (val) val.textContent = r >= 1000 ? (r / 1000) + 'km' : r + 'm';
            });
            radiusRangeEl.addEventListener('change', (e) => {
                const idx = parseInt(e.target.value);
                const r = radiusSteps[idx] || currentRadius;
                setRadius(r);
            });
            // initialize label
            syncRadiusUI(currentRadius);
        }
    </script>

    <script
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCqSLJUWJnLLrXpXFzEwQqcTf3-7prKa-4&callback=initMap&loading=async"
        async defer>
    </script>
</body>
</html>
